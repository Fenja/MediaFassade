// Generated by CoffeeScript 1.9.3

/*

The compiled custom_body.js will be included at the end of the html body section after the include of socket.io and stk-framework.
Define your functions here.
 */
var activatePlayer, basketTollerance, bombSpeed, bombTime, bottom, calcSide, checkCollision, checkCollisions, clear, collect, columnWidth, columns, customLogger, customLoggerD, customLoggerT, custom_message_handler, deactivatePlayer, directionAcceleration, directionJoystick, directionKey, directionOrientation, draggable_accelerationsensor_handler, draggable_joystick_handler, draggable_keylistener_handler, draggable_orientationsensor_handler, draggable_touchpad_handler, fadeLimit, fallCount, fallObjects, fallRound, falls, fillObjectList, fps, getClientID, getNewColumn, getPlayer, gravity, heaven, inactivePlayers, influencePlayer, jump, jumpHeight, lastColumn, leftrightDefault, object0, object1, object2, objectBomb, objectDown, objectList, objectPower, objectWidth, objects, player1, player2, player3, player4, player5, player6, playerHeight, playerMap, playerWidth, players, powerSpeed, powerTime, queue, readyAndGo, registerPlayer, running, timeLimit, tollerance, unregisteredPlayer, update, updateInfluence, updateObjects, updatePlayer, updatePlayers, updateTime, updownDefault, upsideDownDevice, viewportHeight, viewportWidth,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

customLogger = function(s) {
  return console.log("customLogger", s);
};

customLoggerT = function() {

  /*customLogger "Timer" */
  update();
  return clear();
};

customLoggerD = function() {

  /*customLogger "Delay" */
  return stk.framework.timer(100, customLoggerT);
};

stk.framework.delay(500, customLoggerD);


/* Define your handler */

custom_message_handler = function(msg) {
  return console.log('Do something with msg: ' + JSON.stringify(msg));
};

draggable_keylistener_handler = function(msg) {
  console.log('Do something with msg: ' + JSON.stringify(msg));
  return directionKey(msg);
};

draggable_joystick_handler = function(msg) {
  console.log('Do something with msg: ' + JSON.stringify(msg));
  return directionJoystick(msg);
};

draggable_orientationsensor_handler = function(msg) {
  upsideDownDevice(msg);
  return directionOrientation(msg);
};

draggable_accelerationsensor_handler = function(msg) {
  return directionAcceleration(msg);
};

draggable_touchpad_handler = function(msg) {
  var id, player;
  id = msg.envelop.clientid;
  player = playerMap[id];
  if (player !== void 0) {
    return activatePlayer(player);
  }
};


/* Register your handler */

stk.framework.register_handler('custommessage', custom_message_handler);

stk.framework.register_handler('draggable_joystick', draggable_joystick_handler);

stk.framework.register_handler('draggable_keylistener', draggable_keylistener_handler);

stk.framework.register_handler('draggable_orientationsensor', draggable_orientationsensor_handler);

stk.framework.register_handler('draggable_accelerationsensor', draggable_accelerationsensor_handler);

stk.framework.register_handler('draggable_touchpad', draggable_touchpad_handler);


/*
Doing "onLoad"-Stuff
If you want a function be called after the last script (it is this script - custom_end.coffee/custom_end.js) is loaded, add your code here.
If it should be executed after the "loading..." animation ends, add a delay call of 1200 ms
 */

console.log("ready");

readyAndGo = function() {
  return console.log("go");
};

stk.framework.delay(1200, readyAndGo);


/* own code */

viewportHeight = window.innerHeight;

viewportWidth = window.innerWidth;

fps = 50;

running = true;

tollerance = -2;

gravity = 5;

heaven = parseInt($('#blend').css('height'), 10) * 5;

bottom = 0;

jumpHeight = 300;

updownDefault = 3;

leftrightDefault = 0.8;

player1 = {
  name: "player1",
  up: false,
  left: false,
  right: false,
  jumps: false,
  falls: false,
  speed: {
    updown: updownDefault,
    leftright: leftrightDefault
  },
  height: bottom,
  side: 50,
  influenceTime: 0,
  dom: $('#player1'),
  basketDom: $('#basket1'),
  basketimageDom: $('#basketimage1'),
  score: 0,
  scoreDom: $('#score1'),
  time: 0,
  isActive: false,
  basketTurnedOver: new Date().getTime() / 1000,
  waitForBasket: false,
  timeout: $('#timeout1')
};

player2 = {
  name: "player2",
  up: false,
  left: false,
  right: false,
  jumps: false,
  falls: false,
  speed: {
    updown: updownDefault,
    leftright: leftrightDefault
  },
  height: bottom,
  side: 250,
  influenceTime: 0,
  dom: $('#player2'),
  basketDom: $('#basket2'),
  basketimageDom: $('#basketimage2'),
  score: 0,
  scoreDom: $('#score2'),
  time: 0,
  isActive: false,
  basketTurnedOver: new Date().getTime() / 1000,
  waitForBasket: false,
  timeout: $('#timeout2')
};

player3 = {
  name: "player3",
  up: false,
  left: false,
  right: false,
  jumps: false,
  falls: false,
  speed: {
    updown: updownDefault,
    leftright: leftrightDefault
  },
  height: bottom,
  side: 250,
  influenceTime: 0,
  dom: $('#player3'),
  basketDom: $('#basket3'),
  basketimageDom: $('#basketimage3'),
  score: 0,
  scoreDom: $('#score3'),
  time: 0,
  isActive: false,
  basketTurnedOver: new Date().getTime() / 1000,
  waitForBasket: false,
  timeout: $('#timeout3')
};

player4 = {
  name: "player4",
  up: false,
  left: false,
  right: false,
  jumps: false,
  falls: false,
  speed: {
    updown: updownDefault,
    leftright: leftrightDefault
  },
  height: bottom,
  side: 250,
  influenceTime: 0,
  dom: $('#player4'),
  basketDom: $('#basket4'),
  basketimageDom: $('#basketimage4'),
  score: 0,
  scoreDom: $('#score4'),
  time: 0,
  isActive: false,
  basketTurnedOver: new Date().getTime() / 1000,
  waitForBasket: false,
  timeout: $('#timeout4')
};

player5 = {
  name: "player5",
  up: false,
  left: false,
  right: false,
  jumps: false,
  falls: false,
  speed: {
    updown: updownDefault,
    leftright: leftrightDefault
  },
  height: bottom,
  side: 250,
  influenceTime: 0,
  dom: $('#player5'),
  basketDom: $('#basket5'),
  basketimageDom: $('#basketimage5'),
  score: 0,
  scoreDom: $('#score5'),
  time: 0,
  isActive: false,
  basketTurnedOver: new Date().getTime() / 1000,
  waitForBasket: false,
  timeout: $('#timeout5')
};

player6 = {
  name: "player6",
  up: false,
  left: false,
  right: false,
  jumps: false,
  falls: false,
  speed: {
    updown: updownDefault,
    leftright: leftrightDefault
  },
  height: bottom,
  side: 250,
  influenceTime: 0,
  dom: $('#player6'),
  basketDom: $('#basket6'),
  basketimageDom: $('#basketimage6'),
  score: 0,
  scoreDom: $('#score6'),
  time: 0,
  isActive: false,
  basketTurnedOver: new Date().getTime() / 1000,
  waitForBasket: false,
  timeout: $('#timeout6')
};

playerMap = {};

players = [];

inactivePlayers = [];

unregisteredPlayer = [player2, player1, player4, player5, player3, player6];

playerWidth = parseInt(player1.dom.css('width'));

playerHeight = parseInt(player1.dom.css('height'));

basketTollerance = 20;

timeLimit = 120;

fadeLimit = 55;

object0 = {
  value: 0,
  name: 'zero',
  height: heaven,
  velo: 5,
  side: 10,
  dom: $('#zero')
};

object1 = {
  value: 1,
  name: 'one',
  height: heaven,
  velo: 5,
  side: 40,
  dom: $('#one')
};

object2 = {
  value: 2,
  name: 'two',
  height: heaven,
  velo: gravity,
  side: 40,
  dom: $('#two')
};

objectBomb = {
  value: -1,
  name: 'bomb',
  height: heaven,
  velo: gravity,
  side: 40,
  dom: $('#bomb')
};

objectPower = {
  value: 1,
  name: 'power',
  height: heaven,
  velo: gravity,
  side: 40,
  dom: $('#power')
};

objectWidth = parseInt(object1.dom.css('width'));

objects = [object0, object1, object2, objectBomb, objectPower];

objectList = [];

queue = [object0, object1, object2, objectBomb, objectPower];

fallCount = 0;

fallRound = 10;

columns = 12;

columnWidth = viewportWidth / (2 + columns);

lastColumn = 0;

bombTime = 50;

powerTime = 75;

bombSpeed = 0.5;

powerSpeed = 2;


/* Own methods */

getPlayer = function(id) {
  var ref;
  if (playerMap[id] !== void 0) {
    if (ref = playerMap[id], indexOf.call(players, ref) >= 0) {
      return playerMap[id];
    } else {
      return void 0;
    }
  } else {
    return registerPlayer(id);
  }
};

directionAcceleration = function(msg) {
  var player;
  player = getPlayer(msg.envelop.clientid);
  if (player !== void 0) {
    if (msg.dev.z > 10) {
      player.jumps = true;
    }
  }
  return true;
};

directionOrientation = function(msg) {
  var player;
  player = getPlayer(msg.envelop.clientid);
  if (player !== void 0 && player.isActive) {
    if (Math.abs(msg.b) > 10) {
      player.speed.leftright = Math.abs(Math.max(50, msg.b)) / 10;
    }
    if (msg.b > 10) {
      player.right = true;
    }
    if (msg.b < -10) {
      player.left = true;
    }
  }
  return true;
};

upsideDownDevice = function(msg) {
  var countdown, id, now, player;
  id = msg.envelop.clientid;
  player = playerMap[id];
  if (player !== void 0) {
    if (player.waitForBasket) {
      if (!player.isActive && !msg.isup) {
        player.basketTurnedOver = new Date().getTime() / 1000 + 10;
        player.waitForBasket = false;
        return console.log("BASKET TURNED OVER @ ", player.basketTurnedOver);
      }
    } else {
      now = new Date().getTime() / 1000;
      if (!player.isActive && !msg.isup) {
        console.log("BASKET TURNED OVER waiting ", player.basketTurnedOver, id, "wait", now, player.basketTurnedOver);
        countdown = Math.max(Math.floor(player.basketTurnedOver - now), 0);
        player.dom.css('opacity', 0.8);
        if (countdown < 5) {
          player.timeout.html(countdown + " Korb umdrehen !");
        } else {
          player.timeout.html(countdown);
        }
      }
      if (!player.isActive && msg.isup && player.basketTurnedOver <= now) {
        console.log("TURN ON PLAYER ", id);
        player.timeout.html("###");
        activatePlayer(player);
      }
      if (!player.isActive && msg.isup && player.basketTurnedOver > now) {
        console.log("TURN ON PLAYER ", id, "wait", player.basketTurnedOver - now);
        countdown = Math.max(Math.floor(player.basketTurnedOver - now), 0);
        player.dom.css('opacity', 0.8);
        return player.timeout.html(countdown);
      }
    }
  } else {
    return console.log("player " + id + "undefined", playerMap);
  }
};

directionJoystick = function(msg) {
  var player, type, x, y;
  player = getPlayer(msg.envelop.clientid);
  if (player !== void 0) {
    x = msg.x;
    y = msg.y;
    type = msg.type;
    if (y < 0.4 && y < x - 0.1) {
      player.up = true;
    } else if (x < 0.4 && x < y - 0.1) {
      player.left = true;
    } else if (x > 0.6 && x > y + 0.1) {
      player.right = true;
    }
  }
  return true;
};

directionKey = function(msg) {
  var code, i, id, keys, len, player;
  id = msg.envelop.clientid;
  player = getPlayer(id);
  console.log(player, id);
  if (player !== void 0) {
    keys = msg.keys;
    for (i = 0, len = keys.length; i < len; i++) {
      code = keys[i];
      if (code === 37) {
        player.left = true;
      }
      if (code === 38) {
        player.up = true;
      }
      if (code === 39) {
        player.right = true;
      }
    }
  }
  return true;
};

registerPlayer = function(id) {
  var player;
  console.log("registerPlayer", unregisteredPlayer);
  if (unregisteredPlayer.length > 0) {
    player = unregisteredPlayer.pop();
    inactivePlayers.push(player);
    activatePlayer(player);
    playerMap[id] = player;
    console.log("playerMap", playerMap);
    player.dom.css('left', 10 + "px");
    return player;
  } else {
    return void 0;
  }
};

activatePlayer = function(player) {
  var index;
  players.push(player);
  index = inactivePlayers.indexOf(player);
  inactivePlayers = inactivePlayers.splice(index);
  player.time = new Date().getTime() / 1000;
  player.score = 0;
  player.dom.css('opacity', 1.0);
  player.dom.css('zIndex', 5);
  player.isActive = true;
  player.basketTurnedOver = new Date().getTime() / 1000;
  return true;
};

deactivatePlayer = function(player) {
  var index;
  if (player.isActive) {
    inactivePlayers.push(player);
    index = players.indexOf(player);
    players = players.splice(index);
    player.dom.css('opacity', 0.3);
    player.dom.css('zIndex', 2);
    player.isActive = false;
    player.waitForBasket = true;
    player.timeout.html("10");
    player.height = bottom;
    player.dom.css('bottom', player.height + "px");
    console.log("deactivatePlayer", JSON.stringify(player));
  }

  /*else
    console.log "player is not active",JSON.stringify(player)
   */
  return true;
};

update = function() {
  updatePlayers();
  updateObjects();
  return checkCollisions();
};

updatePlayers = function() {
  var i, len, now, player;
  now = new Date().getTime() / 1000;
  for (i = 0, len = players.length; i < len; i++) {
    player = players[i];
    if (updateTime(player, now)) {
      updatePlayer(player);
    }
  }
  return true;
};

updatePlayer = function(player) {
  var basketLeft, playerLeft;
  playerLeft = parseInt(player.dom.css('left'));
  basketLeft = parseInt(player.basketDom.css('left'));
  if (player.isActive) {
    if (player.left && player.side > 0) {
      player.side -= 5 * player.speed.leftright;
      if (basketLeft <= -1 * basketTollerance) {
        player.dom.css('left', player.side + "px");
      } else {
        player.basketDom.css('left', parseInt((player.side - playerLeft) / 2) + "px");
      }
    } else if (player.right && player.side + playerWidth < viewportWidth) {
      player.side += 5 * player.speed.leftright;
      player.dom.css('left', player.side + "px");
      if (basketLeft >= basketTollerance) {
        player.dom.css('left', player.side + "px");
      } else {
        player.basketDom.css('left', parseInt((player.side - playerLeft) / 2) + "px");
      }
    }
    if (player.jumps || player.falls) {
      jump(player);
      player.dom.css('left', player.side + "px");
      player.basketDom.css('left', "0px");
    } else if (player.up) {
      jump(player);
      player.dom.css('left', player.side + "px");
      player.basketDom.css('left', "0px");
    }
    updateInfluence(player);
  } else if (player.jumps || player.falls) {
    jump(player);
    player.basketDom.css('left', player.side + "px");
    player.basketDom.css('left', "0px");
  }
  return true;
};

updateInfluence = function(player) {
  if (player.influence > 0) {
    player.influence -= 1;
    if (player.influence === 0) {
      player.speed = {
        updown: updownDefault,
        leftright: leftrightDefault
      };
    }
  }
  return true;
};

updateTime = function(player, now) {
  var timeleft;
  if ((now - player.time) >= timeLimit) {
    deactivatePlayer(player);
    return false;
  } else if ((now - player.time) >= fadeLimit) {
    player.dom.css('opacity', 0.7);
    return true;
  } else {
    timeleft = Math.max(0, timeLimit - Math.floor(now - player.time));
    if (timeleft < 21) {
      player.timeout.html("Noch " + timeleft + "s");
    }
    if (timeleft < 6 && timeleft > 0) {
      player.dom.not(':animated').effect('pulsate', {
        times: 4
      }, 500, function() {});
      player.timeout.html("Noch " + timeleft + "s");
    } else {
      player.timeout.html("");
    }
    return true;
  }
};

jump = function(player) {
  if (player.height <= bottom) {
    player.jumps = true;
  } else if (player.height >= jumpHeight + bottom) {
    player.jumps = false;
    player.falls = true;
  }
  if (player.jumps) {
    player.height += 10 * player.speed.updown;
  } else if (player.falls) {
    player.height -= 10 * player.speed.updown;
    if (player.height <= bottom) {
      player.falls = false;
    }
  }
  player.dom.css('bottom', player.height + "px");
  return true;
};

updateObjects = function() {
  fallObjects();
  fillObjectList();
  return true;
};

fallObjects = function() {
  var i, len, object;
  for (i = 0, len = objectList.length; i < len; i++) {
    object = objectList[i];
    falls(object);
  }
  return true;
};

fillObjectList = function() {
  var index, object;
  if (queue.length > 0) {
    fallCount += 1;
    if (fallCount >= fallRound) {
      object = queue[0];
      object.side = getNewColumn() * columnWidth + columnWidth;
      object.dom.css('left', object.side + "px");
      objectList.push(object);
      index = queue.indexOf(object);
      queue.splice(index, 1);
      fallCount = 0;
    }
  }
  return true;
};

falls = function(object) {
  if (object !== void 0) {
    object.height -= object.velo;
    if (object.height <= bottom) {
      objectDown(object);
    }
    object.dom.css('bottom', object.height + "px");
  }
  return true;
};

getNewColumn = function() {
  return Math.floor(Math.random() * columns);
};

checkCollisions = function() {
  var i, len, object;
  for (i = 0, len = objectList.length; i < len; i++) {
    object = objectList[i];
    checkCollision(object);
  }
  return true;
};

checkCollision = function(object) {
  var i, len, lrtest, objPos, player, playerPos, udtest;
  for (i = 0, len = players.length; i < len; i++) {
    player = players[i];
    if (object !== void 0 && player.isActive) {
      playerPos = player.basketimageDom.offset();
      playerPos.top = parseInt(playerPos.top, 10);
      playerPos.left = parseInt(parseInt(playerPos.left, 10));
      playerPos.right = playerPos.left + parseInt(player.basketimageDom.css('width'), 10);
      playerPos.right = parseInt(playerPos.right);
      playerPos.bottom = playerPos.top + parseInt(player.basketimageDom.css('height'), 10);
      objPos = object.dom.offset();
      objPos.top = parseInt(objPos.top, 10);
      objPos.left = parseInt(objPos.left, 10);
      objPos.right = objPos.left + parseInt(player.dom.css('width'), 10);
      objPos.bottom = objPos.top + parseInt(player.dom.css('height'), 10);
      objPos.middle = parseInt((objPos.right - objPos.left) / 2 + objPos.left, 10);
      lrtest = objPos.middle >= playerPos.left && objPos.middle <= playerPos.right;
      udtest = objPos.bottom >= playerPos.top && objPos.bottom <= playerPos.bottom;
      if (object.name === 'bomb') {
        console.log(JSON.stringify(playerPos), JSON.stringify(objPos), lrtest, udtest);
      }
      if (lrtest && udtest) {
        switch (object.name) {
          case 'bomb':
            player.dom.not(':animated').effect('shake', {
              times: 4
            }, 500, function() {});
            break;
          case 'power':
            player.dom.not(':animated').effect('highlight', {
              times: 4
            }, 500, function() {});
        }
        collect(player, object);
      }
    }
  }
  return true;
};

objectDown = function(object) {
  var index;
  object.height = heaven;
  object.dom.css('bottom', heaven + "px");
  queue.push(object);
  index = objectList.indexOf(object);
  objectList.splice(index, 1);
  calcSide(object);
  return true;
};

calcSide = function(object) {
  object.dom.css('left', object.side + "px");
  return true;
};

collect = function(player, object) {
  console.log("Collected Object");
  player.score += object.value;
  player.scoreDom.html(player.score);
  influencePlayer(player, object);
  objectDown(object);
  return true;
};

influencePlayer = function(player, object) {
  if (object.name === 'bomb') {
    player.influence = bombTime;
    player.speed = {
      updown: bombSpeed,
      leftright: bombSpeed
    };
    stk.framework.sendMessage('custommessage', {
      type: 'addVibratePattern',
      sendTo: [getClientID(player)],
      pattern: {
        id: "viacustommessage",
        timestamp: new Date().getTime() + 2000,
        list: [0, 2000, 500, 2000]
      }
    });
  } else if (object === 'power') {
    player.influence = powerTime;
    player.speed = {
      updown: powerSpeed,
      leftright: powerSpeed
    };
  }
  return true;
};

clear = function() {
  var i, len, player;
  for (i = 0, len = players.length; i < len; i++) {
    player = players[i];
    player.up = false;
    player.left = false;
    player.right = false;
  }
  return true;
};

getClientID = function(player) {
  var i, id, len, results;
  results = [];
  for (i = 0, len = playerMap.length; i < len; i++) {
    id = playerMap[i];
    if (playerMap[id] === player) {
      results.push(id);
    } else {
      results.push(void 0);
    }
  }
  return results;

  /*
  stk.framework
  
  stk.framework.timer [TIME_IN_MS as int, FUNCTION_NAME]
  every TIME_IN_MS milli seconds repeat FUNCTION_NAME 
  
  stk.framework.delay TIME_IN_MS, FUNCTION_NAME
  after TIME_IN_MS milli seconds execute FUNCTION_NAME once
  
  stk.framework.isVibrationSupported
  returns [true | false]
  
  stk.framework.addVibratePattern pattern
  pattern={id:STRING,timestamp:[timestamp|0],list:[PAUSE_MS,VIBRATE_MS,PAUSE_MS,VIBRATE_MS,...,PAUSE_MS,VIBRATE_MS]}
  id: identifier of a pattern
  timstamp: starttime as local timestamp.
          if the timestamp lays in the past list will be truncated by the difference of timestamp to local time
          if the timestamp till the time of the last ms of the last VIBRATE_MS lays bevore the local time the pattern will be dropped
          if timestamp == 0 the pattern will be started immediately
          if a new pattern starts while another pattern runs, the runnig pattern will be played and the part of new pattern that lasts longer than the playing pattern will be played subsequent to end of the running pattern. No pattern mixing occurs 
  Example
  pattern={id:"whge",timestamp:new Date().getTime()+2200,list:[500,1000,200,300]}
  
  stk.framework.removeVibratePattern id
  removes a pattern from scheduling
  if the pattern is playing it will be stopped
  succeeding pattern will be left unchanged, notably beforehand truncated patten will NOT be brought to their original state, there will be a pause in the amount of time the removed pattern would have been played
   */
};


/*
you may get your own cliendID via stk.framework.getClientID()
 */


/*
With the 'custommessage' type  you can send your custom messages to all clients in your group
The 'custommessage' type is also capable to send messages to one ore more specific clients
If you provide an empty list to the sendTo attribute (or omit the sendTo attribute) your message will be broadcasted to any client in your group.
Otherwise, if you declare one or more client ids in the sendTo list, your message will be send only to the listed clients.
 */


/*
Doing "onLoad"-Stuff
If you want a function be called after the last script (it is this script - custom_end.coffee/custom_end.js) is loaded, add your code here.
If it should be executed after the "loading..." animation ends, add a delay call of 1200 ms
 */
